<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Persepolis by jialincater</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Persepolis</h1>
      <h2 class="project-tagline">is an java repo that will figure out the Bayesian Network By the parameters</h2>
      <a href="https://github.com/jialincater/Persepolis" class="btn">View on GitHub</a>
      <a href="https://github.com/jialincater/Persepolis/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jialincater/Persepolis/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="outline" class="anchor" href="#outline" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Outline</h2>

<p>In this project, a BN and a DBN is learned from the given data using Greedy Hill Climbing and random restarts. A directed graph without any edge is seen as the initial graph, then an algorithm called GHC is used and with this method, a better structure is found step by step supported by the scoring function, until a situation that every neighbor of the current status have lower score then the current, then random restart is executed. In this way, the best structure will be get. After that, parameter of this structure can be calculate so that inference can be done to predict the value.</p>

<h2>
<a id="basic-steps" class="anchor" href="#basic-steps" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Steps</h2>

<h3>
<a id="bn-structurelearning" class="anchor" href="#bn-structurelearning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BN StructureLearning</h3>

<p>At the very beginning, structure learning is necessary to find out the best-scored structure in BN. 
With the initial network which has N vertex generated by the data class, in every step in GHC, program will find out the better scored structure in its neighbor, that structure will be seem as current structure. In this way, the current structure will be better and better until the program find a structure that all its neighbor have lower score, that means, a local best is found. To deal with this situation, random restart will be executed, a random graph generator will be called and a new random graph will be returned as the current structure, then GHC is applied again. After several times of random restart, a global best is found.
In the progress above, a TABU list is also applied when checking the neighbor of the current structure, if the neighbor is in the TABU list, ignore it and check the next one, else, calculate its score and add it into TABU list.</p>

<h3>
<a id="dbn-structurelearning" class="anchor" href="#dbn-structurelearning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DBN StructureLearning</h3>

<p>Analogously, structure learning in DBN also use GHC algorithm, random restart and TABU lists. The difference is that structure learning in GHC has 2N vertex(Which is double number of BN), but has no edge from time t to time t or for time t+1 to time t. When learning DBN structures, if a vertex has 3 parent vertex, which is the max number of a vertex, there will not any additional edge points to it.</p>

<h3>
<a id="parameterlearning" class="anchor" href="#parameterlearning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ParameterLearning</h3>

<p>In this step, probabilities should be determined given the optimal structure with certain standard.In the constructor, the test data is given for the program to learn the best structure,
parameterLearning(dyllscore d1,data data1);
Knowing all the parameters , is given by the following expression:
</p><a href="http://imgur.com/aWnMixA"><img src="http://i.imgur.com/aWnMixA.png" title="source: imgur.com"></a>
Note that: N’ are pseudo-counts, which equals 0.5 in this project.
The above formula can be described by the following program:

<pre><code>for(int i=0; i&lt;2*p_numberOfNode; i++){
    for(int j=0; j&lt;p_dyqll[i]; j++){
        for( int k=0; k&lt;p_dyrll[i]; k++){
            theta[i][j][k]=(d1.getCount(i, j, k)+constN)/(d1.getCounts(i, j)+p_dyrll[i]*constN);
        }
    }
}
</code></pre>

<h3>
<a id="inference" class="anchor" href="#inference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Inference</h3>

<p>After leaned the parameters, the DB Network can be used to infer the most probably future data. As known in the section above, θijk, which is the probability that ith variable has kth value with jth parent config is calculated. This set of probability can be used for calculate the most possible values appear in the future.
When predicting the ith variable, all other variable should also be specific so that a set of θijk can be get from the section above. The sum of the set of θijk is the probability of the appearance of the ith variable with the kth value. After compared all the probability that ith variable can take, the one with biggest probability should be the inference value of the ith variable.</p>

<h2>
<a id="scoring-functions" class="anchor" href="#scoring-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scoring functions</h2>

<p>Scoring functions are necessary to calculate scores to the specific structures, a base class is provided to save all the possible algorithms to find the optimal solution to score the structure.In this project, two kinds of algorithms(log-likelihood and minimum description length) are ordered, each of the algorithms implements both the Bayesian network and the dynamic Bayesian network.
This is a abstract class, all the declarations are done in this class.</p>

<h3>
<a id="llscore" class="anchor" href="#llscore" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LLscore</h3>

<p>First, initialize the count[][][] and counts[][] given the train data and the DAG. Then determine the parent nodes of each nodes, 
List ls= digraph1.getPais(data1.getVl().get(n));<br>
Transfer the array of parent nodes in string to integer for convenience. Iterate the rll, determine the number of parents configurations</p>

<pre><code>arrayOfParents[aop]=parent;
qll[n]*=rll[parent];
</code></pre>

<p>After that given the number of nodes, the number of parent configurations of each nodes, number of different values of each nodes, iterate the whole data file, </p>

<pre><code>for(int i=1;i&lt;data1.getCore().size();i++)
for(int j=0;j&lt;data1.getCore().get(i).size();j+=numberOfNode)
</code></pre>

<p>each set of values is corresponding to a certain count[][][],</p>

<pre><code>firstParameter=n;
secondParameter+=coef*weight;
thirdParameter=Integer.parseInt(data1.getCore().get(i).get(n+j));
count[firstParameter][secondParameter][thirdParameter]++;
</code></pre>

<p>Then, it is easy to get the value of counts[][] given the count[][][],</p>

<pre><code>for(int i=0;i&lt;numberOfNode;i++){
    for(int j=0;j&lt;qll[i];j++){
        for(int k=0;k&lt;rll[i];k++){
            counts[i][j]+=count[i][j][k];   
        }
    }
}
</code></pre>

<p>Finally, apply log-likelihood algorithm with all the given parameters to get the final result in the Bayesian network.</p>

<p></p><a href="http://imgur.com/aWnMixA"><img src="http://i.imgur.com/aWnMixA.png" title="source: imgur.com"></a>

<p>Note that:  is count[i][j][k] and  is counts[i][j].</p>

<h3>
<a id="mdlscore" class="anchor" href="#mdlscore" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MDLscore</h3>

<p>Minimum description length is another scoring criterion in this project, all the initialization is done in the constructor.</p>

<pre><code>mdlscore(data data1, Digraph&lt;String&gt; digraph1,double llscore, int[] qll)
</code></pre>

<p>the score of the structure by using minimum description length algorithm can be achieved through the expression below:</p>

<pre><code>dymdlscore = dyllscore - 0.5*Math.log(totalNumber)*B/Math.log(2);
</code></pre>

<p>Note that: is the total number of instances, and  denotes the network complexity, which is given by:</p>

<pre><code>for(int i=0;i&lt;2*numberOfNode;i++){
    B=B+(dyrll[i]-1)*dyqll[i];
}
</code></pre>

<h3>
<a id="dyllscore" class="anchor" href="#dyllscore" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DyLLscore</h3>

<p>In the terms of the log-likelihood score in the dynamic Bayesian network, the calculation is basically the same as it is in the Bayesian network. The difference only lies on the number of nodes, which needs to take careful consideration. Because it depends on two states, the number of nodes in each sets we should be two times of the actual number of nodes.</p>

<pre><code>dyrll = new int[2*numberOfNode];
dyqll=new int[2*numberOfNode];
</code></pre>

<h3>
<a id="dymdlscore" class="anchor" href="#dymdlscore" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DyMDLscore</h3>

<p>In the terms of the minimum description length score in the dynamic Bayesian network comparing to it in the Bayesian network, the only difference also lies on the number of nodes in each set.</p>

<pre><code>dyrmim = new int[2*numberOfNode];
for(int i = 0 ; i&lt;2*numberOfNode ; i++){
    dyrll[i]=rll[i%numberOfNode];
    totalNumber=totalNumber + dyrll[i];
}
</code></pre>

<h2>
<a id="efficiency" class="anchor" href="#efficiency" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Efficiency</h2>

<h3>
<a id="array-arraylist-and-linkedlist" class="anchor" href="#array-arraylist-and-linkedlist" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array, ArrayList and LinkedList</h3>

<p>The time complexity comparison is as follows:
</p><a href="http://imgur.com/gEp0H46"><img src="http://i.imgur.com/gEp0H46.png" title="source: imgur.com"></a>
add() in the table refers to add(E e), and remove() refers to remove(int index)
ArrayList has O(n) time complexity for arbitrary indices of add/remove, but O(1) for the operation at the end of the list.
LinkedList has O(n) time complexity for arbitrary indices of add/remove, but O(1) for operations at end/beginning of the List.
The difference of their performance is obvious. 
<a href="http://imgur.com/o9Pb51K"><img src="http://i.imgur.com/o9Pb51K.png" title="source: imgur.com"></a>
LinkedList is faster in add and remove, but slower in get. Based on the complexity table and testing results, we can figure out when to use ArrayList or LinkedList. In brief, LinkedList should be preferred if:
there are no large number of random access of element
there are a large number of add/remove operations
In our project, the data class need only add data once(The data never changes), but is read several times, so ArrayList is a good choice for data. For other small data structures, LinkedList is seem in high efficiency, and sometimes for the small length-fixed structures, array is used.

<h3>
<a id="directed-graphadjacency-matrix-or-adjacency-list" class="anchor" href="#directed-graphadjacency-matrix-or-adjacency-list" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Directed Graph(Adjacency matrix or adjacency list)</h3>

<p>Adjacency matrix or adjacency list? When facing this problem, it is important to make a decision for that to continue our project. It can not only have impact on the efficiency of the program but also can influence the stability. Multiple factor is considered in our project, as listed below.
</p><a href="http://imgur.com/GirLr1J"><img src="http://i.imgur.com/GirLr1J.png" title="source: imgur.com"></a>

<p>As can be seen in the chart above. An adjacency matrix occupy much more space in the memory, and adjacency list just save what it need. However, adjacency matrix have a higher speed to find a specific edge, but it is slower to iterate though the graph.
In our project, it is rare to have a graph with more than 20 vertex, so it will not occupy lots of memory. What’s more, we always need to look up parents of a specific vertex, which need to Iterate though the graph, so a data structure using adjacency list is generated.</p>

<p></p><a href="http://imgur.com/iDO0Lgj"><img src="http://i.imgur.com/iDO0Lgj.png" title="source: imgur.com"></a>

<h3>
<a id="data-structure-in-parameter-learning" class="anchor" href="#data-structure-in-parameter-learning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data Structure in Parameter Learning</h3>

<p>As we known, the score is typically based on the count[ ][ ][ ] and the counts[ ][ ] in this project. However, iterating the whole data is time-consuming. So we need to estimate the number of different values in each of the dimensions when they are initialized.
Although the number of count[ ][ ][ ] and counts[ ][ ] is fixed given the structure, it is impossible to determine how many parent configurations or even which nodes are the parents of a certain node. So in order not to receive exceptions in the project. We initial the count[ ][ ][ ] and count[ ][ ] with maximum value for secure purpose. Also it turns out to save the memories comparing to the condition if we initialize them with a relatively large number.</p>

<pre><code>theta =
 new double[2*p_numberOfNode][p_rll[max]*p_rll[max]*p_rll[max]][p_rll[max]];

count = new int[2*numberOfNode][rll[max]*rll[max]*rll[max]][rll[max]];
        counts = new int[2*numberOfNode][rll[max]*rll[max]*rll[max]];

count = new int[numberOfNode][rll[max]*rll[max]*rll[max]][rll[max]];
        counts = new int[numberOfNode][rll[max]*rll[max]*rll[max]];
</code></pre>

<h2>
<a id="polymorphic" class="anchor" href="#polymorphic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Polymorphic</h2>

<h3>
<a id="polymorphic-in-scoring-function" class="anchor" href="#polymorphic-in-scoring-function" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Polymorphic in scoring function</h3>

<p>The scoring function is where we implement the polymorphism to redefine the method resultOfScore based on different kinds of scoring criterion. Concerning that there are various kinds of algorithm to score and select the best structure independently. We provide the base class scoringfunction where all the attributes are declared in this class.
Also, we made the scoringfunction class an abstract class with an abstract method resultOfScore, so you can’t not initialize an object of scoringfunction type, instead the specific type is recommended at the beginning.</p>

<pre><code>public abstract class scoringfunction  
public abstract double resultOfScore();
</code></pre>

<h3>
<a id="polymorphic-in-structure-learning" class="anchor" href="#polymorphic-in-structure-learning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Polymorphic in Structure Learning</h3>

<p>The structure learning functions also use polymorphic to make it possible to extend other possible solutions in a gentle way. in our project, structure learning function is like the graph below.
As can be seen in the graph, the Learn class is abstract and it has 2 abstract function to be override and 1 function that is declared and defined. In the DLearn and SLearn classes, the function learnStructures() and dagGen() are overrided because they behave different when learning BN and DBN.
<a href="http://imgur.com/dXcRwvl"><img src="http://i.imgur.com/dXcRwvl.png" title="source: imgur.com"></a></p>

<h2>
<a id="a-little-bit-more-work" class="anchor" href="#a-little-bit-more-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A little bit more work</h2>

<p>After finished programming the project, we run our program several times with the sets of data given. The result sometimes appears to be concentrated on only one number, after trying to debug our program, we found that sometimes the possibility of a variable taking different values are same, and after the “find-max” iterate, the first-max value remains. 
To fix that problem, we generate a random list. When the situation above is occurred, a random value with highest score is chosen.  </p>

<h2>
<a id="outcomes--conclusion" class="anchor" href="#outcomes--conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Outcomes &amp; conclusion</h2>

<p>Though our program is not tested on the workstation in the Lab. We can ensure that our program can run smoothly on a windows or a Mac with 2 different scoring functions and 2 sets of data. Here is the outcome of our test data on a Macbook.</p>

<h2>
<a id="group-member" class="anchor" href="#group-member" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Group Member</h2>

<p></p><a href="http://imgur.com/PcmSpJn"><img src="http://i.imgur.com/PcmSpJn.png" title="source: imgur.com"></a>

<h2>
<a id="agradecimentos" class="anchor" href="#agradecimentos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Agradecimentos</h2>

<p>Thank to Prof. Alexandra Carvalho supporting our project, especially for the doubt session in English, we really appreciate that!</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jialincater/Persepolis">Persepolis</a> is maintained by <a href="https://github.com/jialincater">jialincater</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
